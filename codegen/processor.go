package codegen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"github.com/ethereum/go-ethereum/accounts/abi"
)

var ErrNoEvents = errors.New("no events")

const tmplProcessor = `
// Code generated by github.com/withtally/ethgen, DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

{{range $handler := .Processors}}
	type {{.Type}}Processor interface {
		Setup(address common.Address, eth bind.ContractBackend) error
    	Initialize(ctx context.Context, bh *types.Header, emit func(string, []interface{})) error
		{{range .Events}}
			Process{{.Normalized.Name}}(ctx context.Context, e *{{$handler.Type}}{{.Normalized.Name}}, emit func(string, []interface{})) error
		{{end}}
		mustEmbedUnimplemented{{.Type}}Processor()
	}

	type Unimplemented{{.Type}}Processor struct {
		Address  common.Address
		ABI      abi.ABI
		Contract *{{.Type}}
		Eth      bind.ContractBackend
	}

	func (h *Unimplemented{{.Type}}Processor) Setup(address common.Address, eth bind.ContractBackend) error {
		contract, err := New{{.Type}}(address, eth)
		if err != nil {
			return fmt.Errorf("new {{.Type}}: %w", err)
		}

		abi, err := abi.JSON(strings.NewReader(string({{.Type}}ABI)))
		if err != nil {
			return fmt.Errorf("parsing {{.Type}} abi: %w", err)
		}

		h.Address = address
		h.ABI = abi
		h.Contract = contract
		h.Eth = eth
		return nil
	}

	func (h *Unimplemented{{.Type}}Processor) ProcessElement(p interface{}) func(context.Context, types.Log, func(string, []interface{})) error {
		return func(ctx context.Context, vLog types.Log, emit func(string, []interface{})) error {
			switch vLog.Topics[0].Hex() {
			{{range .Events}}
			case h.ABI.Events["{{.Normalized.Name}}"].ID.Hex():
				e := new({{$handler.Type}}{{.Normalized.Name}})
				if err := h.UnpackLog(e, "{{.Normalized.Name}}", vLog); err != nil {
					return fmt.Errorf("unpacking {{.Normalized.Name}}: %w", err)
				}

				e.Raw = vLog
				if err := p.({{$handler.Type}}Processor).Process{{.Normalized.Name}}(ctx, e, emit); err != nil {
					return fmt.Errorf("processing {{.Normalized.Name}}: %w", err)
				}
			{{end}}
			}
			return nil
		}
	}

	func (h *Unimplemented{{$handler.Type}}Processor) UnpackLog(out interface{}, event string, log types.Log) error {
		if len(log.Data) > 0 {
			if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
				return err
			}
		}
		var indexed abi.Arguments
		for _, arg := range h.ABI.Events[event].Inputs {
			if arg.Indexed {
				indexed = append(indexed, arg)
			}
		}
		return abi.ParseTopics(out, indexed, log.Topics[1:])
	}

	func (h *Unimplemented{{$handler.Type}}Processor) Initialize(ctx context.Context, bh *types.Header, emit func(string, []interface{})) error {
		return nil
	}

	{{range .Events}}
		func (h *Unimplemented{{$handler.Type}}Processor) Process{{.Normalized.Name}}(ctx context.Context, e *{{$handler.Type}}{{.Normalized.Name}}, emit func(string, []interface{})) error {
			return nil
		}
	{{end}}

	func (h *Unimplemented{{$handler.Type}}Processor) mustEmbedUnimplemented{{$handler.Type}}Processor() {}
{{end}}
`

type tmplEventData struct {
	Original   abi.Event // Original event as parsed by the abi package
	Normalized abi.Event // Normalized version of the parsed fields
}

type tmplProcessorData struct {
	Type   string
	Events map[string]*tmplEventData
}

type tmplData struct {
	Package    string
	Processors map[string]*tmplProcessorData
}

func GenerateProcessor(types []string, abis []string, pkg string) (string, error) {
	var handlers = make(map[string]*tmplProcessorData)
	var n int

	for i, typ := range types {
		var events = make(map[string]*tmplEventData)
		evmABI, err := abi.JSON(strings.NewReader(abis[i]))
		if err != nil {
			return "", fmt.Errorf("parsing abi: %w", err)
		}

		for _, original := range evmABI.Events {
			// Skip anonymous events as they don't support explicit filtering
			if original.Anonymous {
				continue
			}
			// Normalize the event for capital cases and non-anonymous outputs
			normalized := original
			normalized.Name = abi.ToCamelCase(original.Name)

			events[original.Name] = &tmplEventData{Original: original, Normalized: normalized}
		}

		if len(events) > 0 {
			handlers[typ] = &tmplProcessorData{
				Type:   abi.ToCamelCase(typ),
				Events: events,
			}
			n++
		}
	}

	if n == 0 {
		return "", ErrNoEvents
	}

	data := &tmplData{
		Package:    pkg,
		Processors: handlers,
	}

	buffer := new(bytes.Buffer)
	tmpl := template.Must(template.New("").Parse(tmplProcessor))
	if err := tmpl.Execute(buffer, data); err != nil {
		return "", err
	}

	handler, err := format.Source(buffer.Bytes())
	if err != nil {
		return "", err
	}

	return string(handler), nil
}
